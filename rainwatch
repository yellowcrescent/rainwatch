#!/usr/bin/env python
# coding=utf-8
###############################################################################
#
# rainwatch
# Rainwatch: Deluge RPC client and download manager
#
# @author   J. Hipps <jacob@ycnrg.org>
# @repo     https://bitbucket.org/yellowcrescent/rainwatch
#
# Copyright (c) 2016 J. Hipps / Neo-Retro Group
#
# https://ycnrg.org/
#
# @deps     rwatch
#
###############################################################################

import sys
import os
import re
import json
import signal
import optparse
import operator
import time
import socket
import subprocess
from datetime import datetime

from rwatch.logthis import C,LL,logthis,ER,failwith,loglevel,print_r,exceptionHandler
from rwatch import rcfile,deluge,ruleparser,jabber

class xsetup:
    """Contains version information and globals"""
    ## Version info
    version = "0.10.4"
    vdate   = "03 Jan 2015"

    config = None
    lconfig = None
    defaults = {
                    'run': {
                        'torid': None,
                        'quiet': False,
                        'list': False,
                        'json': False,
                        'full': False
                    },
                    'core': {
                        'loglevel': LL.INFO,
                        'rules': 'rainwatch.rules'
                    },
                    'xfer': {
                        'hostname': None,
                        'user': None,
                        'basepath': ''
                    },
                    'notify': {
                        'hostname': None,
                        'user': None,
                        'icon': ""
                    },
                    'xmpp': {
                        'user': None,
                        'pass': None,
                        'server': None,
                        'sendto': None
                    },
                    'deluge': {
                        'user': "",
                        'pass': "",
                        'hostname': "localhost",
                        'port': 58846
                    }
               }

def show_banner():
    """
    Display banner
    """
    print ""
    print C.CYN, "*** ", C.WHT, "rainwatch", C.OFF
    print C.CYN, "*** ", C.CYN, "Version", xsetup.version, "(" + xsetup.vdate + ")", C.OFF
    print C.CYN, "*** ", C.GRN, "Copyright (c) 2016 J. Hipps / Neo-Retro Group", C.OFF
    print C.CYN, "*** ", C.GRN, "J. Hipps <jacob@ycnrg.org>", C.OFF
    print C.CYN, "*** ", C.YEL, "https://ycnrg.org/", C.OFF
    print ""

def parse_cli():
    """
    Parse command-line options
    """
    global oparser
    oparser = optparse.OptionParser(usage="%prog [options] <[-i] TORRENT_ID>",version=xsetup.version+" ("+xsetup.vdate+")")

    # General options
    oparser.add_option('-v', '--verbose', action="count", dest="run.verbose", help="Increase logging verbosity (-v Verbose, -vv Debug, -vvv Debug2)")
    oparser.add_option('-L','--loglevel', action="store", dest="core.loglevel", default=False,metavar="NUM", help="Logging output verbosity (4=error,5=warning,6=info,7=verbose,8=debug,9=debug2)")
    oparser.add_option('-q', action="store_true", dest="run.quiet", default=False, help="Quiet - suppress log messages (use as first option)")
    oparser.add_option('-i', action="store", dest="run.torid", default=False,metavar="TORID", help="Torrent ID")

    oparser.add_option('-l','--list', action="store_true", dest="run.list", default=False, help="List torrents")
    oparser.add_option('-f','--full', action="store_true", dest="run.full", default=False, help="Full output in torrent list")
    oparser.add_option('-j','--json', action="store_true", dest="run.json", default=False, help="Output data as JSON")

    options, args = oparser.parse_args(sys.argv[1:])
    vout = vars(options)

    if len(args) >= 1:
        vout['run.torid'] = args[0]

    if vout['run.verbose']:
        vout['run.verbose'] += 6
        vout['core.loglevel'] = vout['run.verbose']
    if vout['run.verbose'] or vout['core.loglevel']:
        loglevel(int(vout['core.loglevel']))
    if vout['run.quiet']:
        vout['core.loglevel'] = LL.ERROR
        loglevel(vout['core.loglevel'])

    return vout

def fmtsize(insize,rate=False,bits=False):
    """format human-readable file size and xfer rates"""
    onx = float(abs(insize))
    for u in ['B','K','M','G','T','P']:
        if onx < 1024.0:
            tunit = u
            break
        onx /= 1024.0
    suffix = ""
    if u != 'B': suffix = "iB"
    if rate:
        if bits:
            suffix = "bps"
            onx *= 8.0
        else:
            suffix += "/sec"
    if tunit == 'B':
        ostr = "%3d %s%s" % (onx,tunit,suffix)
    else:
        ostr = "%3.01f %s%s" % (onx,tunit,suffix)
    return ostr

def rexec(optlist,supout=False):
    """execute command; input a list of options; if `supout` is True, then suppress stderr"""
    logthis("Executing:",suffix=optlist,loglevel=LL.DEBUG)
    try:
        if supout:
            fout = subprocess.check_output(optlist,stderr=subprocess.STDOUT)
        else:
            fout = subprocess.check_output(optlist)
    except subprocess.CalledProcessError as e:
        logthis("exec failed:",suffix=e,loglevel=LL.ERROR)
        fout = None
    return fout

def libnotify_send(msgText,hname=False,huser=False,msgTimeout=10000,msgHead=False,msgIcon=False):
    """send libnotify notification to another host via ssh"""
    # use defaults
    if not hname: hname = xsetup.config['notify']['hostname']
    if not huser: huser = xsetup.config['notify']['user']

    # set up notification icon
    if msgIcon: xicon = "-i '%s'" % (msgIcon)
    elif msgIcon == False and xsetup.config['xfer']['notify']['icon']: xicon = "-i '%s'" % (xsetup.config['xfer']['notify']['icon'])
    else: xicon = ''

    # if no message header, then use our hostname
    if msgHead == False: msgHead = socket.gethostname()
    else: msgHead = [msgHead]

    # escape newlines and such
    msgText = "'%s'" % (msgText.replace("\n","\\n").replace("\r","\\r").replace("\t","\\t"))

    # get dbus session address
    dbsout = rexec(['/usr/bin/ssh',hname,'--','ps','aux','|','grep',huser])
    dbus_addr = re.search('dbus-daemon --fork --session --address=(.+)', dbsout, re.I|re.M).group(1)
    logthis("Got dbus session:",suffix=dbus_addr,loglevel=LL.VERBOSE)

    # send notification
    rexec(['/usr/bin/ssh',hname,'--',"DBUS_SESSION_BUS_ADDRESS=\'%s\'" % (dbus_addr),'notify-send','-t',str(msgTimeout),xicon,msgHead,msgText])
    logthis("Sent libnotify message to remote host",loglevel=LL.VERBOSE)


def mode_list():
    global dlx

    # if torrent ID is specified, use it to filter
    if xsetup.config['run']['torid']:
        fltr = { 'id': xsetup.config['run']['torid'] }
    else:
        fltr = {}

    # get list of torrents
    if xsetup.config['run']['full']:
        torlist = dlx.getTorrentList(filter=fltr,fields=[])
    else:
        torlist = dlx.getTorrentList(filter=fltr)

    if xsetup.config['run']['json']:
        print json.dumps(torlist,indent=4,separators=(',', ': '))
    else:
        for ti,tv in torlist.iteritems():
            print "%s: %s (%0.01f) [%s]" % (ti,tv['name'],tv['progress'],tv['tracker_host'])

def mode_chook(tid):
    global dlx,jbx

    # get torrent data
    logthis(">> Processing 'complete' exec hook for",suffix=tid,loglevel=LL.INFO)
    tordata = dlx.getTorrent(tid)

    # find matching rules
    rname,rset = ruleparser.match(tordata)
    if rname:
        logthis("++ Matched ruleset:\n",suffix=print_r(rset),loglevel=LL.VERBOSE)
    else:
        logthis("!! No ruleset matched",loglevel=LL.WARNING)

    # move to destination dir
    if rset.get('moveto',None):
        if dlx.moveTorrent(tid, rset['moveto']):
            logthis("** Moved to",suffix=rset['moveto'],loglevel=LL.INFO)
            # super-hacky/lazy way to ensure Deluge has moved the file before we attempt to xfer it
            time.sleep(3)
        else:
            logthis("!! Failed to move to",suffix=rset['moveto'],loglevel=LL.ERROR)

    # get updated data
    tordata = dlx.getTorrent(tid)

    # download
    if xsetup.config['xfer']['hostname']:
        # send xfer start notification
        if xsetup.config['notify']['user'] and xsetup.config['notify']['hostname']:
            try:
                libnotify_send("%s\n\nStarted transfer to incoming." % (tordata['name']))
            except Exception as e:
                logthis("Failed to send libnotify message:",suffix=e,loglevel=LL.ERROR)

        # xfer via scp
        tgpath = "%s/%s" % (tordata['save_path'],tordata['name'])
        if not os.path.exists(tgpath):
            logthis("!! Path does not exist:",suffix=tgpath,loglevel=LL.ERROR)
            return False
        else:
            logthis(">> Target path:",suffix=tgpath,loglevel=LL.INFO)
        logthis(">> Starting transfer to remote host:",suffix="%s:%s" % (xsetup.config['xfer']['hostname'],xsetup.config['xfer']['basepath']),loglevel=LL.INFO)
        xstart = datetime.now()
        rexec(['/usr/bin/scp','-B','-r',tgpath,"%s:'%s'" % (xsetup.config['xfer']['hostname'],xsetup.config['xfer']['basepath'])])
        xstop = datetime.now()
        logthis("** Transfer complete.",loglevel=LL.INFO)

        # send xfer complete notification
        xdelta = xstop - xstart
        xdelta_str = re.sub('\.[0-9]+$','',str(xdelta))
        tsize = tordata['total_size']
        trate = float(tsize) / float(xdelta.seconds)
        tsize_str = fmtsize(tsize)
        trate_str = fmtsize(trate,rate=True)
        trate_bstr = fmtsize(trate,rate=True,bits=True)
        if jbx:
            jbx.sendmsg(xsetup.config['xmpp']['sendto'],"%s -- Transfer Complete (%s) -- Time Elapsed ( %s ) -- Rate [ %s | %s ]" % (tordata['name'],tsize_str,xdelta_str,trate_str,trate_bstr))

    # done
    logthis("*** Finished with complete exec hook for",suffix=tordata['name'],loglevel=LL.INFO)
    return True

##############################################################################
## Entry point
##

if __name__ == '__main__':

    # Show banner
    if len(sys.argv) < 2 or sys.argv[1] != '--version' and sys.argv[1][1] != 'q':
        show_banner()

    # Set default loglevel
    loglevel(xsetup.defaults['core']['loglevel'])

    # parse CLI options and load running config
    xopt = parse_cli()
    rcfile.loadConfig(cliopts=xopt)
    loglevel(xsetup.config['core']['loglevel'])

    # Set quiet exception handler for non-verbose operation
    if xsetup.config['core']['loglevel'] < LL.VERBOSE:
        sys.excepthook = exceptionHandler

    # parse rules file
    ruleparser.parse()

    # connect to deluge
    dlx = deluge.delcon(xsetup.config['deluge']['user'], xsetup.config['deluge']['pass'], xsetup.config['deluge']['hostname'], int(xsetup.config['deluge']['port']))

    # connect to jabber
    if xsetup.config['xmpp']['user'] and xsetup.config['xmpp']['pass']:
        jbx = jabber.client(xsetup.config['xmpp']['user'], xsetup.config['xmpp']['pass'])
    else:
        jbx = None

    ## process commands

    # get list of torrents
    if xsetup.config['run']['list']:
        mode_list()
    elif xsetup.config['run']['torid']:
        mode_chook(xsetup.config['run']['torid'])
    else:
        logthis("Nothing to do.",loglevel=LL.WARNING)
